<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í…Œë‹ˆìŠ¤ ëŒ€ì§„í‘œ (ì •ë³´ ì €ì¥ ê¸°ëŠ¥)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:400,700&display=swap" rel="stylesheet">
 <style>
    html, body { margin:0; padding:0; }
    body { font-family:'Noto Sans KR', Arial, sans-serif; margin:0; background: #f5f8fa; color:#222; font-size: 17px;}
    .main-wrap { max-width: 700px; margin:0 auto; padding:20px 2vw 30px 2vw; }
    h1, h2, h3 { font-family:'Noto Sans KR', Arial, sans-serif; }
    h1 { font-size:1.7em; }
    h2 { color:#0077b6; margin-bottom:0.9em; font-size:1.25em;}
    .place-title { font-size:1.12em; color:#444; margin-bottom:1.4em;}
    .player-box { background:#e3eef7; border-radius: 0.8em; padding: 1.2em 1em; margin-bottom:1.5em; }
    .player-box strong {color:#18529d;}
    .player-list-ul { margin:0.8em 0 0 0; padding-left:1.2em; }
    .court-title { font-weight:bold; color:#18529d;}
    .rest-note { color:#888; font-size:0.97em; margin-left:0.6em;}
    .winner { font-weight: bold; color: #008542; letter-spacing:1px;}
    .updated {font-size:1em; color:#888; margin-bottom:1.2em;}
    .round-title {margin:2.0em 0 0.7em 0; font-size:1.14em;}
    .scroll-table { overflow-x:auto; margin-bottom:1.4em; }
    table { width:100%; min-width:440px; border-radius:0.8em; box-shadow:0 1.5px 8px #ccd6df33; background:white;}
    th, td { border:1px solid #e2e8f0; padding:12px 8px; text-align:center;}
    th { background:#f2f7fb; color:#18529d; font-size:1em;}
    td.team { font-weight:500;}
    .courtA { background: #f7fafc;}
    .courtB { background: #fff8ed;}
    .settings label { font-size:1.04em; margin-right:1.3em; }
    .id-box {margin-bottom:18px;}
    .id-label { font-size:1.04em; color:#18529d; margin-right:7px;}
    .id-value { font-size:1.02em; color:#138;}
    input[type=text] {
      font-size: 1.09em; padding: 8px 6px; border-radius: 8px; border:1.5px solid #aac6de; margin: 5px 0;
      background: #f7fbfe;
      min-width:450px; max-width:550px;
    }
    select {
      font-size:1em; padding: 6px 10px; border-radius: 7px; border: 1.2px solid #97b5c4; background:#f5fcff;
      min-width:60px;
    }
    button {
      font-size: 1.08em;
      padding: 10px 24px;
      margin-right: 8px;
      margin-top: 7px;
      margin-bottom: 14px;
      background: #eaf3fa;
      color: #0077b6;
      border:1.3px solid #b8d7ee;
      border-radius:7px;
      cursor:pointer;
      font-family:'Noto Sans KR', Arial, sans-serif;
      box-shadow: 0 1px 6px #ccd6df22;
    }
    .player-preview { font-size: 0.98em; color:#444; margin: 5px 0 2px 0; }
    .player-list {margin-bottom: 20px;}
    @media (max-width:600px) {
      body { font-size: 16px; }
      .main-wrap { max-width:100vw; padding:8px 2vw 14vw 2vw; }
      .player-box { padding:0.8em 0.7em; font-size:0.99em;}
      h1 { font-size:1.18em;}
      h2 { font-size:1em;}
      .round-title { font-size:1em;}
      table, th, td { font-size:0.97em;}
      input[type=text], select, button { font-size:1em;}
      th, td { padding:9px 5px;}
    }
    @media (max-width:430px) {
      .main-wrap {padding:2px 0vw 10vw 0vw;}
      .player-list-ul {padding-left:0.8em;}
      table { min-width:350px;}
    }
  </style>
</head>
<body>
 <script type="module">
        // Firebase ì•± ì´ˆê¸°í™” ë° Firestore ì„œë¹„ìŠ¤ ì„í¬íŠ¸
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

        // ì—¬ëŸ¬ë¶„ì˜ Firebase í”„ë¡œì íŠ¸ ì„¤ì •
        // ì´ ì •ë³´ëŠ” Firebase Console > í”„ë¡œì íŠ¸ ì„¤ì • > ì¼ë°˜ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        const firebaseConfig = {
          apiKey: "AIzaSyBBuPKpGMRHSYw5TB1HGI4DIlmfDC8LQjI",
          authDomain: "tennisgame-47.firebaseapp.com",
          projectId: "tennisgame-47",
          storageBucket: "tennisgame-47.firebasestorage.app",
          messagingSenderId: "973659600083",
          appId: "1:973659600083:web:141ae5b5d602cf784f5026",
          measurementId: "G-KKEYH3XNVW"
        };

        // Firebase ì•± ì´ˆê¸°í™”
        const app = initializeApp(firebaseConfig);
        // Firestore ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
        const db = getFirestore(app);
        let dbId = localStorage.getItem("tennis_id") || "shared";
        document.getElementById('idInput').value = dbId;
        document.getElementById('idShow').textContent = dbId ? ` (í˜„ì¬: ${dbId})` : '';
        document.getElementById('idInput').addEventListener('change', function(){
          dbId = this.value.trim() || "shared";
          document.getElementById('idShow').textContent = dbId ? ` (í˜„ì¬: ${dbId})` : '';
          localStorage.setItem("tennis_id", dbId);
          readTestData(); // ID ë°”ê¾¸ë©´ í•´ë‹¹ ID ë°ì´í„° ì¦‰ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°
        });

        // HTML ìš”ì†Œ ì°¸ì¡°
        const outputDiv = document.getElementById('output');
        const writeDataBtn = document.getElementById('writeDataBtn');
        const readDataBtn = document.getElementById('readDataBtn');

        // Firestoreì— ë°ì´í„° ì“°ëŠ” í•¨ìˆ˜
       async function writeTestData() {
            try {
                const docRef = doc(db, "tennis", dbId);
                await setDoc(docRef, {
                    playerNames: playerNames,
                    settings: settings,
                    results: results,
                    updated: new Date()
                });
                outputDiv.innerHTML = `âœ… Firestoreì— ë°ì´í„° ì“°ê¸° ì„±ê³µ! (tennis/${dbId})`;
            } catch (error) {
                outputDiv.innerHTML = `âŒ Firestore ë°ì´í„° ì“°ê¸° ì‹¤íŒ¨: ${error.message}`;
            }
        }

        // Firestoreì—ì„œ ë°ì´í„° ì½ëŠ” í•¨ìˆ˜
        async function readTestData() {
            try {
                const docRef = doc(db, "tennis", dbId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const d = docSnap.data();
                    playerNames = d.playerNames || playerNames;
                    settings = d.settings || settings;
                    results = d.results || results;
                    autoUpdateMatchups();
                    render();

                    outputDiv.innerHTML = `âœ… Firestoreì—ì„œ ë°ì´í„° ì½ê¸° ì„±ê³µ!`;
                    // outputDiv.innerHTML = `âœ… Firestoreì—ì„œ ë°ì´í„° ì½ê¸° ì„±ê³µ! <br>ë‚´ìš©: ${JSON.stringify(d, null, 2)}`;
                    console.log("Document data:", d);
                } else {
                    // ë¬¸ì„œê°€ ì—†ì„ ê²½ìš°
                    outputDiv.innerHTML = `âš ï¸ ë¬¸ì„œ (tennis/${dbId})ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¨¼ì € ë°ì´í„°ë¥¼ ì¨ë³´ì„¸ìš”!`;
                    //outputDiv.innerHTML = "âš ï¸ ë¬¸ì„œ (test_collection/my_test_document) ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¨¼ì € ë°ì´í„°ë¥¼ ì¨ë³´ì„¸ìš”!";
                    console.log("No such document!");
                }
            } catch (error) {
                outputDiv.innerHTML = `âŒ Firestore ë°ì´í„° ì½ê¸° ì‹¤íŒ¨: ${error.message}`;
                console.error("Error reading document: ", error);
            }
        }

        // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        writeDataBtn.addEventListener('click', writeTestData);
        readDataBtn.addEventListener('click', readTestData);

    </script>
    <h1>ğŸ¾ì‹¤ì‹œê°„ í…Œë‹ˆìŠ¤ ëŒ€ì§„í‘œ (ì •ë³´ ì €ì¥ ê¸°ëŠ¥)ğŸ¾</h1>
    <div class="id-box">
      <label class="id-label" for="idInput">ID:</label>
      <input id="idInput" type="text" value="shared" style="width:120px;" maxlength="24" autocomplete="off">
      <span class="id-value" id="idShow"></span>
    </div>
    <p>ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë°ì´í„° ë² ì´ìŠ¤ì— ë°ì´í„°ë¥¼ Read/Write í•´ë³´ì„¸ìš”.</p>

    <button id="writeDataBtn">ë°ì´í„°ë² ì´ìŠ¤ ë°ì´í„° ì“°ê¸°</button>
    <button id="readDataBtn">ë°ì´í„°ë² ì´ìŠ¤ ë°ì´í„° ì½ê¸°</button>

    <div id="output">
        ì—¬ê¸°ì— ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—… ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤...
    </div>
  <div id="settings"></div>
  <div id="playerInputs"></div>
  <div id="main"></div>
<script>
const NUM_PLAYERS = 10;
const NUM_ROUNDS = 5;
const REST_PLAYERS = [
    [8, 9], [6, 7], [0, 1], [2, 3], [4, 5]
];
const STORAGE_KEY = "tennis_save_2406";

function loadData() {
  const data = localStorage.getItem(STORAGE_KEY);
  if (!data) return null;
  try {
    return JSON.parse(data);
  } catch { return null; }
}
function saveData() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    playerNames, settings, results
  }));
}

let playerNames = Array.from({length: NUM_PLAYERS}, (_, i) => `${i+1}ë²ˆ`);
let settings = { place: "", courtA: "ì½”íŠ¸A", courtB: "ì½”íŠ¸B" };
let results = Array.from({length:NUM_ROUNDS},()=>({
  courtA: { winner:'' },
  courtB: { winner:'' }
}));

let matchups = Array(NUM_ROUNDS).fill(null).map(()=>({
  courtA: {team1:[], team2:[]},
  courtB: {team1:[], team2:[]}
}));

// ë°ì´í„° ë³µì›
const saved = loadData();
if (saved) {
  playerNames = Array.isArray(saved.playerNames) ? saved.playerNames.slice(0, NUM_PLAYERS) : playerNames;
  while (playerNames.length < NUM_PLAYERS) playerNames.push(`${playerNames.length+1}ë²ˆ`);
  settings = Object.assign(settings, saved.settings);
  if (Array.isArray(saved.results) && saved.results.length === NUM_ROUNDS) {
    results = saved.results;
  }
}

function saveDataToCloud() {
  db.collection("tennis").doc("shared").set({
    playerNames, settings, results, updated: Date.now()
  });
}
// Firestoreì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°(í˜ì´ì§€ ì§„ì…ì‹œ 1íšŒ, í˜¹ì€ ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆë¡œ)
function loadDataFromCloud(callback) {
  db.collection("tennis").doc("shared")
    .onSnapshot(doc => {
      if (doc.exists) {
        const d = doc.data();
        playerNames = d.playerNames || playerNames;
        settings = d.settings || settings;
        results = d.results || results;
        autoUpdateMatchups();
        render();
        if (callback) callback();
      }
    });
}

function assignFirstRound() {
  const rest = REST_PLAYERS[0];
  const available = Array.from({length:playerNames.length}, (_,i)=>i).filter(i=>!rest.includes(i));
  const sorted = [...available].sort((a,b)=>a-b);
  matchups[0] = {
    courtA: {team1:[sorted[0],sorted[1]], team2:[sorted[2],sorted[3]]},
    courtB: {team1:[sorted[4],sorted[5]], team2:[sorted[6],sorted[7]]}
  };
}
function getTopPlayers(players, n=1) {
  return [...players].sort((a,b)=>a-b).slice(0,n);
}
function teamKey(team) {
  return [...team].sort((a,b)=>a-b).join('-');
}
function safeTeams(courtPlayers, forbiddenTeamKeys) {
  const ps = courtPlayers;
  const combs = [
    [[ps[0],ps[1]],[ps[2],ps[3]]],
    [[ps[0],ps[2]],[ps[1],ps[3]]],
    [[ps[0],ps[3]],[ps[1],ps[2]]]
  ];
  for (let c of combs) {
    let overlap = false;
    for (let t of c) if (forbiddenTeamKeys.has(teamKey(t))) overlap = true;
    if (!overlap) return c;
  }
  return combs[0];
}
function computeNextMatchups(round) {
  if (round === 0) return;
  const prev = matchups[round-1];
  const prevRest = REST_PLAYERS[round-1];
  const curRest = REST_PLAYERS[round];
  const available = Array.from({length:playerNames.length}, (_,i)=>i).filter(i=>!curRest.includes(i));
  let prevA_win = [], prevA_lose = [], prevB_win = [], prevB_lose = [];
  let resA = results[round-1].courtA;
  if(resA.winner==='1') { prevA_win = prev.courtA.team1; prevA_lose = prev.courtA.team2; }
  else if(resA.winner==='2') { prevA_win = prev.courtA.team2; prevA_lose = prev.courtA.team1; }
  let resB = results[round-1].courtB;
  if(resB.winner==='1') { prevB_win = prev.courtB.team1; prevB_lose = prev.courtB.team2; }
  else if(resB.winner==='2') { prevB_win = prev.courtB.team2; prevB_lose = prev.courtB.team1; }
  function pickForGroup(group) {
    let actual = group.filter(p=>!curRest.includes(p));
    let need = group.length - actual.length;
    if(need > 0) {
      let prevRestAvailable = prevRest.filter(p=>available.includes(p));
      actual = actual.concat(getTopPlayers(prevRestAvailable, need));
    }
    return actual;
  }
  let aWinners = pickForGroup(prevA_win);
  let aLosers  = pickForGroup(prevA_lose);
  let bWinners = pickForGroup(prevB_win);
  let bLosers  = pickForGroup(prevB_lose);
  // í•œ ë¼ìš´ë“œ ë‚´ ì¤‘ë³µ ì—†ì´ ë°°ì •
  let used = [];
  let courtAplayers = [...aWinners, ...bWinners].filter((v,i,arr)=>arr.indexOf(v)===i).filter(i=>available.includes(i));
  courtAplayers = getTopPlayers(courtAplayers, 4); used = [...courtAplayers];
  let fillA = available.filter(i=>!used.includes(i));
  while (courtAplayers.length < 4 && fillA.length > 0) { courtAplayers.push(fillA[0]); used.push(fillA[0]); fillA = fillA.slice(1);}
  let courtBplayers = [...aLosers, ...bLosers].filter((v,i,arr)=>arr.indexOf(v)===i).filter(i=>available.includes(i) && !used.includes(i));
  courtBplayers = getTopPlayers(courtBplayers, 4); used = used.concat(courtBplayers);
  let fillB = available.filter(i=>!used.includes(i));
  while (courtBplayers.length < 4 && fillB.length > 0) { courtBplayers.push(fillB[0]); used.push(fillB[0]); fillB = fillB.slice(1);}
  let courtA_sorted = getTopPlayers(courtAplayers, 4);
  let courtB_sorted = getTopPlayers(courtBplayers, 4);

  // ì „ ë¼ìš´ë“œ íŒ€ ì €ì¥
  let prevTeamsA = [], prevTeamsB = [];
  if (matchups[round-1] && matchups[round-1].courtA.team1.length === 2 && matchups[round-1].courtA.team2.length === 2)
    prevTeamsA = [matchups[round-1].courtA.team1, matchups[round-1].courtA.team2];
  if (matchups[round-1] && matchups[round-1].courtB.team1.length === 2 && matchups[round-1].courtB.team2.length === 2)
    prevTeamsB = [matchups[round-1].courtB.team1, matchups[round-1].courtB.team2];

  // ê¸ˆì§€í‚¤ ì„¤ì •(ëª¨ë“  í¬ë¡œìŠ¤+ë™ì¼ì½”íŠ¸ ì¤‘ë³µë°©ì§€)
  let forbiddenA = new Set(), forbiddenB = new Set();
  prevTeamsA.forEach(team => {forbiddenA.add(teamKey(team)); forbiddenB.add(teamKey(team));});
  prevTeamsB.forEach(team => {forbiddenA.add(teamKey(team)); forbiddenB.add(teamKey(team));});

  let [a_t1, a_t2] = safeTeams(courtA_sorted, forbiddenA);
  let [b_t1, b_t2] = safeTeams(courtB_sorted, forbiddenB);

  matchups[round] = {
    courtA: {team1: a_t1, team2: a_t2},
    courtB: {team1: b_t1, team2: b_t2}
  };
}

function autoUpdateMatchups() {
  assignFirstRound();
  for(let r=1; r<NUM_ROUNDS; r++) {
    let prevResA = results[r-1].courtA.winner;
    let prevResB = results[r-1].courtB.winner;
    if(prevResA && prevResB) computeNextMatchups(r);
    else matchups[r] = {courtA:{team1:[],team2:[]}, courtB:{team1:[],team2:[]}};
  }
}

function renderPlayerInputs() {
  let html = `<div class="player-list">
    <strong>ì„ ìˆ˜ ì´ë¦„ (ì‰¼í‘œë¡œ êµ¬ë¶„):</strong><br>
    <input type="text" value="${playerNames.join(',')}" onchange="setPlayerNames(this.value)">
    <div class="player-preview">[ í˜„ì¬ ì„ ìˆ˜ëª…: ${playerNames.map((name,i)=>name+`(${i+1})`).join(', ')} ]</div>
    <span style="font-size:0.93em;color:#666;">* 10ëª…ê¹Œì§€ ì…ë ¥, ì´ˆê³¼ ì‹œ ì• 10ëª…ë§Œ ì‚¬ìš©</span>
  </div>`;
  document.getElementById('playerInputs').innerHTML = html;
}

function renderSettings() {
  let html = `<div class="settings">
    <label>ì¥ì†Œ:
      <input type="text" value="${settings.place}" onchange="setSettings('place', this.value)">
    </label>
    <label><br>ì½”íŠ¸A ì´ë¦„:
      <input type="text" value="${settings.courtA}" onchange="setSettings('courtA', this.value)">
    </label>
    <label><br>ì½”íŠ¸B ì´ë¦„:
      <input type="text" value="${settings.courtB}" onchange="setSettings('courtB', this.value)">
    </label>
  </div>`;
  document.getElementById('settings').innerHTML = html;
}

window.setWinner = function(roundIdx, court, value) {
  if(court==='A') results[roundIdx].courtA.winner = value;
  else results[roundIdx].courtB.winner = value;
  saveData(); // <- ì €ì¥
  autoUpdateMatchups();
  render();
};
window.setPlayerNames = function(val) {
  playerNames = val.split(',').map(s=>s.trim()).filter(Boolean);
  while (playerNames.length < NUM_PLAYERS) playerNames.push(`${playerNames.length+1}ë²ˆ`);
  playerNames = playerNames.slice(0, NUM_PLAYERS);
  saveData(); // <- ì €ì¥
  autoUpdateMatchups();
  render();
};
window.setSettings = function(key, value) {
  settings[key] = value;
  saveData(); // <- ì €ì¥
  render();
};

function render() {
  renderSettings();
  renderPlayerInputs();
  let html = `<h3 style="margin-bottom:0">${settings.place?settings.place:''}</h3>`;
  for(let round=0; round<NUM_ROUNDS; round++) {
    const rest = REST_PLAYERS[round].map(i=>playerNames[i]).join(', ');
    html += `<h3 style="margin-top:2em">${round+1}ë¼ìš´ë“œ <span style="font-size:0.9em;">(íœ´ì‹: ${rest})</span></h3>
      <table>
        <tr>
          <th>ì½”íŠ¸</th>
          <th>íŒ€1</th>
          <th>íŒ€2</th>
          <th>ìŠ¹ë¦¬íŒ€</th>
        </tr>`;
    ['A','B'].forEach(court => {
      let match = matchups[round][`court${court}`];
      let courtName = (court==='A') ? settings.courtA : settings.courtB;
      let t1 = match.team1.map(i=>playerNames[i]).join(', ');
      let t2 = match.team2.map(i=>playerNames[i]).join(', ');
      html += `<tr class="court${court}">
        <td>${courtName}</td>
        <td>${t1}</td>
        <td>${t2}</td>
        <td>
          <select onchange="setWinner(${round},'${court}',this.value)" ${match.team1.length<2?'disabled':''}>
            <option value="">-</option>
            <option value="1" ${results[round][`court${court}`].winner==='1'?'selected':''}>íŒ€1</option>
            <option value="2" ${results[round][`court${court}`].winner==='2'?'selected':''}>íŒ€2</option>
          </select>
        </td>
      </tr>`;
    });
    html += `</table>`;
  }
  document.getElementById('main').innerHTML = html;
}

autoUpdateMatchups();
render();
</script>
</body>
</html>
