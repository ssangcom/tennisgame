<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í…Œë‹ˆìŠ¤ ëŒ€ì§„í‘œ (ì •ë³´ ì €ì¥ ê¸°ëŠ¥)</title>
  <style>
    body { font-family: Arial; margin: 2rem; }
    table, th, td { border: 1px solid #aaa; border-collapse: collapse; padding: 8px; }
    th { background: #f6f6f6; }
    .courtA { background: #e0f7fa; }
    .courtB { background: #fff3e0; }
    input[type=text] { width: 350px; padding: 2px 4px;}
    .settings { margin-bottom: 2em; }
    .settings label { margin-right: 1.2em; }
    .player-list { margin-bottom: 1.5em; }
    .player-preview { font-size: 0.97em; color: #333; margin-bottom: 0.5em; }
  </style>
</head>
<body>
 <script type="module">
        // Firebase ì•± ì´ˆê¸°í™” ë° Firestore ì„œë¹„ìŠ¤ ì„í¬íŠ¸
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

        // ì—¬ëŸ¬ë¶„ì˜ Firebase í”„ë¡œì íŠ¸ ì„¤ì •
        // ì´ ì •ë³´ëŠ” Firebase Console > í”„ë¡œì íŠ¸ ì„¤ì • > ì¼ë°˜ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        const firebaseConfig = {
          apiKey: "AIzaSyBBuPKpGMRHSYw5TB1HGI4DIlmfDC8LQjI",
          authDomain: "tennisgame-47.firebaseapp.com",
          projectId: "tennisgame-47",
          storageBucket: "tennisgame-47.firebasestorage.app",
          messagingSenderId: "973659600083",
          appId: "1:973659600083:web:141ae5b5d602cf784f5026",
          measurementId: "G-KKEYH3XNVW"
        };

        // Firebase ì•± ì´ˆê¸°í™”
        const app = initializeApp(firebaseConfig);
        // Firestore ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
        const db = getFirestore(app);

        // HTML ìš”ì†Œ ì°¸ì¡°
        const outputDiv = document.getElementById('output');
        const writeDataBtn = document.getElementById('writeDataBtn');
        const readDataBtn = document.getElementById('readDataBtn');

        // Firestoreì— ë°ì´í„° ì“°ëŠ” í•¨ìˆ˜
        async function writeTestData() {
            try {
                // 'test_collection' ì»¬ë ‰ì…˜ ì•ˆì— 'my_test_document'ë¼ëŠ” ë¬¸ì„œ ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
                const docRef = doc(db, "tennis", "shared");
                await setDoc(docRef, {
                    playerNames: playerNames,
                    settings: settings,
                    results: results,
                    updated: new Date()
                });
                outputDiv.innerHTML = "âœ… Firestoreì— ë°ì´í„° ì“°ê¸° ì„±ê³µ! (tennis)";
                console.log("Document successfully written!");
            } catch (error) {
                outputDiv.innerHTML = `âŒ Firestore ë°ì´í„° ì“°ê¸° ì‹¤íŒ¨: ${error.message}`;
                console.error("Error writing document: ", error);
            }
        }

        // Firestoreì—ì„œ ë°ì´í„° ì½ëŠ” í•¨ìˆ˜
        async function readTestData() {
            try {
                const docRef = doc(db, "tennis", "shared");
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const d = docSnap.data();
                    playerNames = d.playerNames || playerNames;
                    settings = d.settings || settings;
                    results = d.results || results;
                    autoUpdateMatchups();
                    render();

                    outputDiv.innerHTML = `âœ… Firestoreì—ì„œ ë°ì´í„° ì½ê¸° ì„±ê³µ! <br>ë‚´ìš©: ${JSON.stringify(d, null, 2)}`;
                    console.log("Document data:", d);
                } else {
                    // ë¬¸ì„œê°€ ì—†ì„ ê²½ìš°
                    outputDiv.innerHTML = "âš ï¸ ë¬¸ì„œ (test_collection/my_test_document) ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¨¼ì € ë°ì´í„°ë¥¼ ì¨ë³´ì„¸ìš”!";
                    console.log("No such document!");
                }
            } catch (error) {
                outputDiv.innerHTML = `âŒ Firestore ë°ì´í„° ì½ê¸° ì‹¤íŒ¨: ${error.message}`;
                console.error("Error reading document: ", error);
            }
        }

        // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        writeDataBtn.addEventListener('click', writeTestData);
        readDataBtn.addEventListener('click', readTestData);

    </script>
   <h1>ğŸ¾ Firebase Firestore í…ŒìŠ¤íŠ¸ ğŸ¾</h1>
    <p>ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ Firebase Firestoreì— ë°ì´í„°ë¥¼ ì“°ê³  ì½ëŠ” ê²ƒì„ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”.</p>

    <button id="writeDataBtn">Firestoreì— ë°ì´í„° ì“°ê¸°</button>
    <button id="readDataBtn">Firestoreì—ì„œ ë°ì´í„° ì½ê¸°</button>

    <div id="output">
        ì—¬ê¸°ì— Firestore ì‘ì—… ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤...
    </div>
  <h2>ì‹¤ì‹œê°„ í…Œë‹ˆìŠ¤ ëŒ€ì§„í‘œ (ì •ë³´ ì €ì¥ ê¸°ëŠ¥)</h2>
  <div class="btnbox">
    <button onclick="saveDataToCloud()">ì €ì¥í•˜ê¸° (í´ë¼ìš°ë“œ)</button>
    <button onclick="loadDataFromCloud(true)">ë¶ˆëŸ¬ì˜¤ê¸° (í´ë¼ìš°ë“œ)</button>
    <span style="color:#888;font-size:0.93em;">(ì‹¤ì‹œê°„ ë™ê¸°í™”ëŠ” ë³„ë„ë¡œ)</span>
  </div>
  <div id="settings"></div>
  <div id="playerInputs"></div>
  <div id="main"></div>
<script>
const NUM_PLAYERS = 10;
const NUM_ROUNDS = 5;
const REST_PLAYERS = [
  [0, 9], [1, 8], [2, 7], [3, 6], [4, 5]
];
const STORAGE_KEY = "tennis_save_2406";

function loadData() {
  const data = localStorage.getItem(STORAGE_KEY);
  if (!data) return null;
  try {
    return JSON.parse(data);
  } catch { return null; }
}
function saveData() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    playerNames, settings, results
  }));
}

let playerNames = Array.from({length: NUM_PLAYERS}, (_, i) => `${i+1}ë²ˆ`);
let settings = { place: "", courtA: "ì½”íŠ¸A", courtB: "ì½”íŠ¸B" };
let results = Array.from({length:NUM_ROUNDS},()=>({
  courtA: { winner:'' },
  courtB: { winner:'' }
}));

let matchups = Array(NUM_ROUNDS).fill(null).map(()=>({
  courtA: {team1:[], team2:[]},
  courtB: {team1:[], team2:[]}
}));

// ë°ì´í„° ë³µì›
const saved = loadData();
if (saved) {
  playerNames = Array.isArray(saved.playerNames) ? saved.playerNames.slice(0, NUM_PLAYERS) : playerNames;
  while (playerNames.length < NUM_PLAYERS) playerNames.push(`${playerNames.length+1}ë²ˆ`);
  settings = Object.assign(settings, saved.settings);
  if (Array.isArray(saved.results) && saved.results.length === NUM_ROUNDS) {
    results = saved.results;
  }
}

function saveDataToCloud() {
  db.collection("tennis").doc("shared").set({
    playerNames, settings, results, updated: Date.now()
  });
}
// Firestoreì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°(í˜ì´ì§€ ì§„ì…ì‹œ 1íšŒ, í˜¹ì€ ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆë¡œ)
function loadDataFromCloud(callback) {
  db.collection("tennis").doc("shared")
    .onSnapshot(doc => {
      if (doc.exists) {
        const d = doc.data();
        playerNames = d.playerNames || playerNames;
        settings = d.settings || settings;
        results = d.results || results;
        autoUpdateMatchups();
        render();
        if (callback) callback();
      }
    });
}

function assignFirstRound() {
  const rest = REST_PLAYERS[0];
  const available = Array.from({length:playerNames.length}, (_,i)=>i).filter(i=>!rest.includes(i));
  const sorted = [...available].sort((a,b)=>a-b);
  matchups[0] = {
    courtA: {team1:[sorted[0],sorted[1]], team2:[sorted[2],sorted[3]]},
    courtB: {team1:[sorted[4],sorted[5]], team2:[sorted[6],sorted[7]]}
  };
}
function getTopPlayers(players, n=1) {
  return [...players].sort((a,b)=>a-b).slice(0,n);
}
function teamKey(team) {
  return [...team].sort((a,b)=>a-b).join('-');
}
function safeTeams(courtPlayers, forbiddenTeamKeys) {
  const ps = courtPlayers;
  const combs = [
    [[ps[0],ps[1]],[ps[2],ps[3]]],
    [[ps[0],ps[2]],[ps[1],ps[3]]],
    [[ps[0],ps[3]],[ps[1],ps[2]]]
  ];
  for (let c of combs) {
    let overlap = false;
    for (let t of c) if (forbiddenTeamKeys.has(teamKey(t))) overlap = true;
    if (!overlap) return c;
  }
  return combs[0];
}
function computeNextMatchups(round) {
  if (round === 0) return;
  const prev = matchups[round-1];
  const prevRest = REST_PLAYERS[round-1];
  const curRest = REST_PLAYERS[round];
  const available = Array.from({length:playerNames.length}, (_,i)=>i).filter(i=>!curRest.includes(i));
  let prevA_win = [], prevA_lose = [], prevB_win = [], prevB_lose = [];
  let resA = results[round-1].courtA;
  if(resA.winner==='1') { prevA_win = prev.courtA.team1; prevA_lose = prev.courtA.team2; }
  else if(resA.winner==='2') { prevA_win = prev.courtA.team2; prevA_lose = prev.courtA.team1; }
  let resB = results[round-1].courtB;
  if(resB.winner==='1') { prevB_win = prev.courtB.team1; prevB_lose = prev.courtB.team2; }
  else if(resB.winner==='2') { prevB_win = prev.courtB.team2; prevB_lose = prev.courtB.team1; }
  function pickForGroup(group) {
    let actual = group.filter(p=>!curRest.includes(p));
    let need = group.length - actual.length;
    if(need > 0) {
      let prevRestAvailable = prevRest.filter(p=>available.includes(p));
      actual = actual.concat(getTopPlayers(prevRestAvailable, need));
    }
    return actual;
  }
  let aWinners = pickForGroup(prevA_win);
  let aLosers  = pickForGroup(prevA_lose);
  let bWinners = pickForGroup(prevB_win);
  let bLosers  = pickForGroup(prevB_lose);
  // í•œ ë¼ìš´ë“œ ë‚´ ì¤‘ë³µ ì—†ì´ ë°°ì •
  let used = [];
  let courtAplayers = [...aWinners, ...bWinners].filter((v,i,arr)=>arr.indexOf(v)===i).filter(i=>available.includes(i));
  courtAplayers = getTopPlayers(courtAplayers, 4); used = [...courtAplayers];
  let fillA = available.filter(i=>!used.includes(i));
  while (courtAplayers.length < 4 && fillA.length > 0) { courtAplayers.push(fillA[0]); used.push(fillA[0]); fillA = fillA.slice(1);}
  let courtBplayers = [...aLosers, ...bLosers].filter((v,i,arr)=>arr.indexOf(v)===i).filter(i=>available.includes(i) && !used.includes(i));
  courtBplayers = getTopPlayers(courtBplayers, 4); used = used.concat(courtBplayers);
  let fillB = available.filter(i=>!used.includes(i));
  while (courtBplayers.length < 4 && fillB.length > 0) { courtBplayers.push(fillB[0]); used.push(fillB[0]); fillB = fillB.slice(1);}
  let courtA_sorted = getTopPlayers(courtAplayers, 4);
  let courtB_sorted = getTopPlayers(courtBplayers, 4);

  // ì „ ë¼ìš´ë“œ íŒ€ ì €ì¥
  let prevTeamsA = [], prevTeamsB = [];
  if (matchups[round-1] && matchups[round-1].courtA.team1.length === 2 && matchups[round-1].courtA.team2.length === 2)
    prevTeamsA = [matchups[round-1].courtA.team1, matchups[round-1].courtA.team2];
  if (matchups[round-1] && matchups[round-1].courtB.team1.length === 2 && matchups[round-1].courtB.team2.length === 2)
    prevTeamsB = [matchups[round-1].courtB.team1, matchups[round-1].courtB.team2];

  // ê¸ˆì§€í‚¤ ì„¤ì •(ëª¨ë“  í¬ë¡œìŠ¤+ë™ì¼ì½”íŠ¸ ì¤‘ë³µë°©ì§€)
  let forbiddenA = new Set(), forbiddenB = new Set();
  prevTeamsA.forEach(team => {forbiddenA.add(teamKey(team)); forbiddenB.add(teamKey(team));});
  prevTeamsB.forEach(team => {forbiddenA.add(teamKey(team)); forbiddenB.add(teamKey(team));});

  let [a_t1, a_t2] = safeTeams(courtA_sorted, forbiddenA);
  let [b_t1, b_t2] = safeTeams(courtB_sorted, forbiddenB);

  matchups[round] = {
    courtA: {team1: a_t1, team2: a_t2},
    courtB: {team1: b_t1, team2: b_t2}
  };
}

function autoUpdateMatchups() {
  assignFirstRound();
  for(let r=1; r<NUM_ROUNDS; r++) {
    let prevResA = results[r-1].courtA.winner;
    let prevResB = results[r-1].courtB.winner;
    if(prevResA && prevResB) computeNextMatchups(r);
    else matchups[r] = {courtA:{team1:[],team2:[]}, courtB:{team1:[],team2:[]}};
  }
}

function renderPlayerInputs() {
  let html = `<div class="player-list">
    <strong>ì„ ìˆ˜ ì´ë¦„ (ì‰¼í‘œë¡œ êµ¬ë¶„):</strong><br>
    <input type="text" value="${playerNames.join(',')}" onchange="setPlayerNames(this.value)">
    <div class="player-preview">[ í˜„ì¬ ì„ ìˆ˜ëª…: ${playerNames.map((name,i)=>name+`(${i+1})`).join(', ')} ]</div>
    <span style="font-size:0.93em;color:#666;">* 10ëª…ê¹Œì§€ ì…ë ¥, ì´ˆê³¼ ì‹œ ì• 10ëª…ë§Œ ì‚¬ìš©</span>
  </div>`;
  document.getElementById('playerInputs').innerHTML = html;
}

function renderSettings() {
  let html = `<div class="settings">
    <label>ì¥ì†Œ:
      <input type="text" value="${settings.place}" onchange="setSettings('place', this.value)">
    </label>
    <label>ì½”íŠ¸A ì´ë¦„:
      <input type="text" value="${settings.courtA}" onchange="setSettings('courtA', this.value)">
    </label>
    <label>ì½”íŠ¸B ì´ë¦„:
      <input type="text" value="${settings.courtB}" onchange="setSettings('courtB', this.value)">
    </label>
  </div>`;
  document.getElementById('settings').innerHTML = html;
}

window.setWinner = function(roundIdx, court, value) {
  if(court==='A') results[roundIdx].courtA.winner = value;
  else results[roundIdx].courtB.winner = value;
  saveData(); // <- ì €ì¥
  autoUpdateMatchups();
  render();
};
window.setPlayerNames = function(val) {
  playerNames = val.split(',').map(s=>s.trim()).filter(Boolean);
  while (playerNames.length < NUM_PLAYERS) playerNames.push(`${playerNames.length+1}ë²ˆ`);
  playerNames = playerNames.slice(0, NUM_PLAYERS);
  saveData(); // <- ì €ì¥
  autoUpdateMatchups();
  render();
};
window.setSettings = function(key, value) {
  settings[key] = value;
  saveData(); // <- ì €ì¥
  render();
};

function render() {
  renderSettings();
  renderPlayerInputs();
  let html = `<h3 style="margin-bottom:0">${settings.place?settings.place:''}</h3>`;
  for(let round=0; round<NUM_ROUNDS; round++) {
    const rest = REST_PLAYERS[round].map(i=>playerNames[i]).join(', ');
    html += `<h3 style="margin-top:2em">${round+1}ë¼ìš´ë“œ <span style="font-size:0.9em;">(íœ´ì‹: ${rest})</span></h3>
      <table>
        <tr>
          <th>ì½”íŠ¸</th>
          <th>íŒ€1</th>
          <th>íŒ€2</th>
          <th>ìŠ¹ë¦¬íŒ€</th>
        </tr>`;
    ['A','B'].forEach(court => {
      let match = matchups[round][`court${court}`];
      let courtName = (court==='A') ? settings.courtA : settings.courtB;
      let t1 = match.team1.map(i=>playerNames[i]).join(', ');
      let t2 = match.team2.map(i=>playerNames[i]).join(', ');
      html += `<tr class="court${court}">
        <td>${courtName}</td>
        <td>${t1}</td>
        <td>${t2}</td>
        <td>
          <select onchange="setWinner(${round},'${court}',this.value)" ${match.team1.length<2?'disabled':''}>
            <option value="">-</option>
            <option value="1" ${results[round][`court${court}`].winner==='1'?'selected':''}>íŒ€1</option>
            <option value="2" ${results[round][`court${court}`].winner==='2'?'selected':''}>íŒ€2</option>
          </select>
        </td>
      </tr>`;
    });
    html += `</table>`;
  }
  document.getElementById('main').innerHTML = html;
}

autoUpdateMatchups();
render();
</script>
</body>
</html>
